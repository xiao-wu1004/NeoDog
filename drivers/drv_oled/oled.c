#include "oled.h"
#include "stdlib.h"
#include "oledfont.h"
#include "drv_systick.h"
#include "drv_all.h"

uint8_t OLED_GRAM[144][8];

//反显函数
void OLED_ColorTurn(uint8_t i)
{
    if(i == 0)
    {
        OLED_WR_Byte(0xA6, OLED_CMD); //正常显示
    }

    if(i == 1)
    {
        OLED_WR_Byte(0xA7, OLED_CMD); //反色显示
    }
}

//屏幕旋转180度
void OLED_DisplayTurn(uint8_t i)
{
    if(i == 0)
    {
        OLED_WR_Byte(0xC8, OLED_CMD); //正常显示
        OLED_WR_Byte(0xA1, OLED_CMD);
    }

    if(i == 1)
    {
        OLED_WR_Byte(0xC0, OLED_CMD); //反转显示
        OLED_WR_Byte(0xA0, OLED_CMD);
    }
}

//延时
void IIC_delay(void)
{
    uint8_t t = 10;

    while(t--);
}

//起始信号
void I2C_Start(void)
{
    OLED_SDA_Set();
    OLED_SCL_Set();
    IIC_delay();
    OLED_SDA_Clr();
    IIC_delay();
    OLED_SCL_Clr();
    IIC_delay();
}

//结束信号
void I2C_Stop(void)
{
    OLED_SDA_Clr();
    OLED_SCL_Set();
    IIC_delay();
    OLED_SDA_Set();
}

//等待信号响应
void I2C_WaitAck(void) //测数据信号的电平
{
    OLED_SDA_Set();
    IIC_delay();
    OLED_SCL_Set();
    IIC_delay();
    OLED_SCL_Clr();
    IIC_delay();
}

//写入一个字节
void Send_Byte(uint8_t dat)
{
    uint8_t i;

    for(i = 0; i < 8; i++)
    {
        if(dat & 0x80) //将dat的8位从最高位依次写入
        {
            OLED_SDA_Set();
        }
        else
        {
            OLED_SDA_Clr();
        }

        IIC_delay();
        OLED_SCL_Set();
        IIC_delay();
        OLED_SCL_Clr();//将时钟信号设置为低电平
        dat <<= 1;
    }
}

//发送一个字节
//mode:数据/命令标志 0,表示命令;1,表示数据;
void OLED_WR_Byte(uint8_t dat, uint8_t mode)
{
    I2C_Start();
    Send_Byte(0x78);
    I2C_WaitAck();

    if(mode)
    {
        Send_Byte(0x40);
    }
    else
    {
        Send_Byte(0x00);
    }

    I2C_WaitAck();
    Send_Byte(dat);
    I2C_WaitAck();
    I2C_Stop();
}

//开启OLED显示
void OLED_DisPlay_On(void)
{
    OLED_WR_Byte(0x8D, OLED_CMD); //电荷泵使能
    OLED_WR_Byte(0x14, OLED_CMD); //开启电荷泵
    OLED_WR_Byte(0xAF, OLED_CMD); //点亮屏幕
}

//关闭OLED显示
void OLED_DisPlay_Off(void)
{
    OLED_WR_Byte(0x8D, OLED_CMD); //电荷泵使能
    OLED_WR_Byte(0x10, OLED_CMD); //关闭电荷泵
    OLED_WR_Byte(0xAE, OLED_CMD); //关闭屏幕
}

//更新显存到OLED
void OLED_Refresh(void)
{
    uint8_t i, n;

    for(i = 0; i < 8; i++)
    {
        OLED_WR_Byte(0xb0+i, OLED_CMD); //设置行起始地址
        OLED_WR_Byte(0x00, OLED_CMD);  //设置低列起始地址
        OLED_WR_Byte(0x10, OLED_CMD);  //设置高列起始地址
        I2C_Start();
        Send_Byte(0x78);
        I2C_WaitAck();
        Send_Byte(0x40);
        I2C_WaitAck();

        for(n = 0; n < 128; n++)
        {
            Send_Byte(OLED_GRAM[n][i]);
            I2C_WaitAck();
        }

        I2C_Stop();
    }
}
//清屏函数
void OLED_Clear(void)
{
    uint8_t i, n;

    for(i = 0; i < 8; i++)
    {
        for(n = 0; n < 128; n++)
        {
            OLED_GRAM[n][i] = 0; //清除所有数据
        }
    }

    OLED_Refresh();//更新显示
}

//画点
//x:0~127
//y:0~63
//t:1 填充 0,清空
void OLED_DrawPoint(uint8_t x, uint8_t y, uint8_t t)
{
    uint8_t i, m, n;
    i = y / 8;
    m = y % 8;
    n = 1 << m;

    if(t)
    {
        OLED_GRAM[x][i] |= n;
    }
    else
    {
        OLED_GRAM[x][i] = ~OLED_GRAM[x][i];
        OLED_GRAM[x][i] |= n;
        OLED_GRAM[x][i] = ~OLED_GRAM[x][i];
    }
}

//画线
//x1,y1:起点坐标
//x2,y2:结束坐标
void OLED_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t mode)
{
    u16 t;
    int xerr = 0, yerr = 0, delta_x, delta_y, distance;
    int incx, incy, uRow, uCol;
    delta_x = x2 - x1; //计算坐标增量
    delta_y = y2 - y1;
    uRow = x1; //画线起点坐标
    uCol = y1;

    if(delta_x > 0)incx = 1; //设置单步方向
    else if (delta_x == 0)incx = 0; //垂直线
    else
    {
        incx = -1;
        delta_x = -delta_x;
    }

    if(delta_y > 0)incy = 1;
    else if (delta_y == 0)incy = 0; //水平线
    else
    {
        incy = -1;
        delta_y = -delta_x;
    }

    if(delta_x > delta_y)distance = delta_x; //选取基本增量坐标轴
    else distance = delta_y;

    for(t = 0; t < distance + 1; t++)
    {
        OLED_DrawPoint(uRow, uCol, mode); //画点
        xerr += delta_x;
        yerr += delta_y;

        if(xerr > distance)
        {
            xerr -= distance;
            uRow += incx;
        }

        if(yerr > distance)
        {
            yerr -= distance;
            uCol += incy;
        }
    }
}
//x,y:圆心坐标
//r:圆的半径
void OLED_DrawCircle(uint8_t x, uint8_t y, uint8_t r)
{
    int a, b, num;
    a = 0;
    b = r;

    while(2 * b * b >= r * r)
    {
        OLED_DrawPoint(x + a, y - b, 1);
        OLED_DrawPoint(x - a, y - b, 1);
        OLED_DrawPoint(x - a, y + b, 1);
        OLED_DrawPoint(x + a, y + b, 1);

        OLED_DrawPoint(x + b, y + a, 1);
        OLED_DrawPoint(x + b, y - a, 1);
        OLED_DrawPoint(x - b, y - a, 1);
        OLED_DrawPoint(x - b, y + a, 1);

        a++;
        num = (a * a + b * b) - r * r; //计算画的点离圆心的距离

        if(num > 0)
        {
            b--;
            a--;
        }
    }
}



//在指定位置显示一个字符,包括部分字符
//x:0~127
//y:0~63
//size1:选择字体 6x8/6x12/8x16/12x24
//mode:0,反色显示;1,正常显示
void OLED_ShowChar(uint8_t x, uint8_t y, uint8_t chr, uint8_t size1, uint8_t mode)
{
    uint8_t i, m, temp, size2, chr1;
    uint8_t x0 = x, y0 = y;

    if(size1 == 8)size2 = 6;
    else size2 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) * (size1 / 2); //得到字体一个字符对应点阵集所占的字节数

    chr1 = chr - ' '; //计算偏移后的值

    for(i = 0; i < size2; i++)
    {
        if(size1 == 8)
        {
            temp = asc2_0806[chr1][i];   //调用0806字体
        }
        else if(size1 == 12)
        {
            temp = asc2_1206[chr1][i];   //调用1206字体
        }
        else if(size1 == 16)
        {
            temp = asc2_1608[chr1][i];   //调用1608字体
        }
        else if(size1 == 24)
        {
            temp = asc2_2412[chr1][i];   //调用2412字体
        }
        else return;

        for(m = 0; m < 8; m++)
        {
            if(temp & 0x01)OLED_DrawPoint(x, y, mode);
            else OLED_DrawPoint(x, y, !mode);

            temp >>= 1;
            y++;
        }

        x++;

        if((size1 != 8) && ((x - x0) == size1 / 2))
        {
            x = x0;
            y0 = y0 + 8;
        }

        y = y0;
    }
}


//显示字符串
//x,y:起点坐标
//size1:字体大小
//*chr:字符串起始地址
//mode:0,反色显示;1,正常显示
void OLED_ShowString(uint8_t x, uint8_t y, uint8_t *chr, uint8_t size1, uint8_t mode)
{
    while((*chr >= ' ') && (*chr <= '~')) //判断是不是非法字符!
    {
        OLED_ShowChar(x, y, *chr, size1, mode);

        if(size1 == 8)x += 6;
        else x += size1 / 2;

        chr++;
    }
}

//m^n
u32 OLED_Pow(uint8_t m, uint8_t n)
{
    u32 result = 1;

    while(n--)
    {
        result *= m;
    }

    return result;
}

//显示数字
//x,y :起点坐标
//num :要显示的数字
//len :数字的位数
//size:字体大小
//mode:0,反色显示;1,正常显示
void OLED_ShowNum(uint8_t x, uint8_t y, u32 num, uint8_t len, uint8_t size1, uint8_t mode)
{
    uint8_t t, temp, m = 0;

    if(size1 == 8)m = 2;

    for(t = 0; t < len; t++)
    {
        temp = (num / OLED_Pow(10, len - t - 1)) % 10;

        if(temp == 0)
        {
            OLED_ShowChar(x + (size1 / 2 + m)*t, y, '0', size1, mode);
        }
        else
        {
            OLED_ShowChar(x + (size1 / 2 + m)*t, y, temp + '0', size1, mode);
        }
    }
}

//显示汉字
//x,y:起点坐标
//num:汉字对应的序号
//mode:0,反色显示;1,正常显示
void OLED_ShowChinese(uint8_t x, uint8_t y, uint8_t num, uint8_t size1, uint8_t mode)
{
    uint8_t m, temp;
    uint8_t x0 = x, y0 = y;
    u16 i, size3 = (size1 / 8 + ((size1 % 8) ? 1 : 0)) * size1; //得到字体一个字符对应点阵集所占的字节数

    for(i = 0; i < size3; i++)
    {
        if(size1 == 16)
        {
            temp = Hzk1[num][i];   //调用16*16字体
        }
        else if(size1 == 24)
        {
            temp = Hzk2[num][i];   //调用24*24字体
        }
        else if(size1 == 32)
        {
            temp = Hzk3[num][i];   //调用32*32字体
        }
        else if(size1 == 64)
        {
            temp = Hzk4[num][i];   //调用64*64字体
        }
        else return;

        for(m = 0; m < 8; m++)
        {
            if(temp & 0x01)OLED_DrawPoint(x, y, mode);
            else OLED_DrawPoint(x, y, !mode);

            temp >>= 1;
            y++;
        }

        x++;

        if((x - x0) == size1)
        {
            x = x0;
            y0 = y0 + 8;
        }

        y = y0;
    }
}

//num 显示汉字的个数
//space 每一遍显示的间隔
//mode:0,反色显示;1,正常显示
void OLED_ScrollDisplay(uint8_t num, uint8_t space, uint8_t mode)
{
    uint8_t i, n, t = 0, m = 0, r;

    while(1)
    {
        if(m == 0)
        {
            OLED_ShowChinese(128, 24, t, 16, mode); //写入一个汉字保存在OLED_GRAM[][]数组中
            t++;
        }

        if(t == num)
        {
            for(r = 0; r < 16 * space; r++) //显示间隔
            {
                for(i = 1; i < 144; i++)
                {
                    for(n = 0; n < 8; n++)
                    {
                        OLED_GRAM[i - 1][n] = OLED_GRAM[i][n];
                    }
                }

                OLED_Refresh();
            }

            t = 0;
        }

        m++;

        if(m == 16)
        {
            m = 0;
        }

        for(i = 1; i < 144; i++) //实现左移
        {
            for(n = 0; n < 8; n++)
            {
                OLED_GRAM[i - 1][n] = OLED_GRAM[i][n];
            }
        }

        OLED_Refresh();
    }
}

//x,y：起点坐标
//sizex,sizey,图片长宽
//BMP[]：要写入的图片数组
//mode:0,反色显示;1,正常显示
void OLED_ShowPicture(uint8_t x, uint8_t y, uint8_t sizex, uint8_t sizey, uint8_t BMP[], uint8_t mode)
{
    u16 j = 0;
    uint8_t i, n, temp, m;
    uint8_t x0 = x, y0 = y;
    sizey = sizey / 8 + ((sizey % 8) ? 1 : 0);

    for(n = 0; n < sizey; n++)
    {
        for(i = 0; i < sizex; i++)
        {
            temp = BMP[j];
            j++;

            for(m = 0; m < 8; m++)
            {
                if(temp & 0x01)OLED_DrawPoint(x, y, mode);
                else OLED_DrawPoint(x, y, !mode);

                temp >>= 1;
                y++;
            }

            x++;

            if((x - x0) == sizex)
            {
                x = x0;
                y0 = y0 + 8;
            }

            y = y0;
        }
    }
}



////-------------------------------------------------------------------------------------------------

///**
//  * @brief  显示GIF单帧
//  * @param  x,y: 显示位置(列,页)
//  * @param  anim: 动画指针
//  * @param  frame_idx: 帧索引
//  * @retval 无
//  */
//void OLED_ShowGIFFrame(uint8_t x, uint8_t y, const GIF_Animation *anim, uint16_t frame_idx)
//{
//    if(anim == NULL || frame_idx >= anim->frame_count) return;
//
//    uint8_t pages = anim->height / 8;
//    if(anim->height % 8) pages++;
//
//    const uint8_t *frame = anim->frames[frame_idx]; // 通过指针数组访问
//    uint16_t index = 0;
//    uint8_t page, col;
//
//    for(page = 0; page < pages; page++) {
//        OLED_WR_Byte(0xB0 + page + y/8, OLED_CMD);
//        OLED_WR_Byte(x & 0x0F, OLED_CMD);
//        OLED_WR_Byte(0x10 | (x >> 4), OLED_CMD);
//
//        I2C_Start();
//        Send_Byte(0x78);
//        I2C_WaitAck();
//        Send_Byte(0x40);
//        I2C_WaitAck();
//
//        for(col = 0; col < anim->width; col++) {
//            Send_Byte(frame[index++]);
//            I2C_WaitAck();
//            if(index >= anim->frame_size) break;
//        }
//
//        I2C_Stop();
//    }
//}

///**
//  * @brief  初始化GIF播放器
//  * @param  player: 播放器指针
//  * @param  anims: 动画数组
//  * @param  count: 动画数量
//  * @retval 无
//  */
//void GIF_Player_Init(GIF_Player *player, GIF_Animation *anims, uint8_t count) {
//    if(player == NULL || anims == NULL || count == 0) return;
//
//    memset(player, 0, sizeof(GIF_Player));
//    player->animations = anims;
//    player->count = count;
//    player->playing = 1;
//}

///**
//  * @brief  更新GIF播放器
//  * @param  player: 播放器指针
//  * @param  x,y: 显示位置
//  * @retval 无
//  */

//void GIF_Player_Update(GIF_Player *player, uint8_t x, uint8_t y) {
//    if(player == NULL || !player->playing || player->count == 0)
//        return;
//
//    GIF_Animation *current = &player->animations[player->current_anim];
//
//    if(++player->frame_counter >= (current->delay_ms / 10)) { // 假设主循环周期10ms
//        player->frame_counter = 0;
//
//        OLED_ShowGIFFrame(x, y, current, player->current_frame);
//
//        if(++player->current_frame >= current->frame_count) {
//            player->current_frame = 0;
//            if(current->loop_count > 0 && --current->loop_count == 0) {
//                player->current_anim = (player->current_anim + 1) % player->count;
//            }
//        }
//    }
//}
///**
//  * @brief  切换到指定动画
//  * @param  player: 播放器指针
//  * @param  anim_index: 动画索引
//  * @retval 0成功, -1失败
//  */
//int GIF_Player_SwitchAnim(GIF_Player *player, uint8_t anim_index) {
//    if(player == NULL || anim_index >= player->count) return -1;
//
//    player->current_anim = anim_index;
//    player->current_frame = 0;
//    player->frame_counter = 0; // 重置计数器
//    return 0;
//}

///**
//  * @brief  控制播放状态
//  * @param  player: 播放器指针
//  * @param  play: 1播放, 0暂停
//  * @retval 无
//  */
//void GIF_Player_Control(GIF_Player *player, uint8_t play) {
//    if(player == NULL) return;
//    player->playing = play;
//}

///**
//  * @brief  设置动画循环次数
//  * @param  player: 播放器指针
//  * @param  anim_index: 动画索引
//  * @param  loop_count: 循环次数
//  * @retval 0成功, -1失败
//  */
//int GIF_Player_SetLoopCount(GIF_Player *player, uint8_t anim_index, uint8_t loop_count) {
//    if(player == NULL || anim_index >= player->count) return -1;
//    player->animations[anim_index].loop_count = loop_count;
//    return 0;
//}

///**
//  * @brief  获取当前动画索引
//  * @param  player: 播放器指针
//  * @retval 当前动画索引
//  */
//uint8_t GIF_Player_GetCurrentAnim(GIF_Player *player) {
//    return (player != NULL) ? player->current_anim : 0;
//}

///**
//  * @brief  获取当前帧索引
//  * @param  player: 播放器指针
//  * @retval 当前帧索引
//  */
//uint8_t GIF_Player_GetCurrentFrame(GIF_Player *player) {
//    return (player != NULL) ? player->current_frame : 0;
//}

///**
//  * @brief  获取播放状态
//  * @param  player: 播放器指针
//  * @retval 1正在播放, 0暂停或无效
//  */
//uint8_t GIF_Player_IsPlaying(GIF_Player *player) {
//    return (player != NULL) ? player->playing : 0;
//}

///**
//  * @brief  重置动画播放器
//  * @param  player: 播放器指针
//  * @retval 无
//  */
//void GIF_Player_Reset(GIF_Player *player) {
//    if(player == NULL) return;
//    player->current_anim = 0;
//    player->current_frame = 0;
//    player->frame_counter = 0;
//}
////-------------------------------------------------------------------------------------------------


///**
//  * @brief  显示GIF动画
//  * @param  x0: 起始列(0-127)
//  * @param  y0: 起始行(0-63)
//  * @param  x1: 终止列(0-127)
//  * @param  y1: 终止行(0-63)
//  * @param  k: 总帧数
//  * @param  m: 单帧数据大小
//  * @param  GIF[][m]: GIF数据数组
//  * @retval 无
//  */
//void OLED_DrawGIF(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, uint8_t k, uint16_t m, uint8_t GIF[][m])
//{
//    uint16_t j = 0; // 数据索引
//    uint8_t x, y, i, page;
//    uint8_t height_pages = (y1 - y0) / 8;
//    if((y1 - y0) % 8) height_pages++;
//
//    for(i = 0; i < k; i++) // 遍历每一帧
//    {
//        j = 0;
//        // 将帧数据写入显存
//        for(page = 0; page < height_pages; page++)
//        {
//            for(x = x0; x < x1; x++)
//            {
//                if(j < m) // 防止数组越界
//                {
//                    OLED_GRAM[x][page + y0/8] = GIF[i][j++];
//                }
//            }
//        }
//
//        OLED_Refresh(); // 更新显示
//        drv_systick_ms(10); // 使用系统延时函数控制帧率
//    }
//}


//OLED的初始化
//pb12->scl
//pb13->sda
void OLED_Init(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE); //使能PORTA~E,PORTG时钟

    //GPIO初始化设置
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12 | GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;//普通输出模式
    GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//推挽输出
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;//100MHz
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;//上拉
    GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化

//	OLED_RES_Clr();
//	drv_systick_ms(200);
//	OLED_RES_Set();

    OLED_WR_Byte(0xAE, OLED_CMD); //--turn off oled panel
    OLED_WR_Byte(0x00, OLED_CMD); //---set low column address
    OLED_WR_Byte(0x10, OLED_CMD); //---set high column address
    OLED_WR_Byte(0x40, OLED_CMD); //--set start line address  Set Mapping RAM Display Start Line (0x00~0x3F)
    OLED_WR_Byte(0x81, OLED_CMD); //--set contrast control register
    OLED_WR_Byte(0xCF, OLED_CMD); // Set SEG Output Current Brightness
    OLED_WR_Byte(0xA1, OLED_CMD); //--Set SEG/Column Mapping     0xa0左右反置 0xa1正常
    OLED_WR_Byte(0xC8, OLED_CMD); //Set COM/Row Scan Direction   0xc0上下反置 0xc8正常
    OLED_WR_Byte(0xA6, OLED_CMD); //--set normal display
    OLED_WR_Byte(0xA8, OLED_CMD); //--set multiplex ratio(1 to 64)
    OLED_WR_Byte(0x3f, OLED_CMD); //--1/64 duty
    OLED_WR_Byte(0xD3, OLED_CMD); //-set display offset	Shift Mapping RAM Counter (0x00~0x3F)
    OLED_WR_Byte(0x00, OLED_CMD); //-not offset
    OLED_WR_Byte(0xd5, OLED_CMD); //--set display clock divide ratio/oscillator frequency
    OLED_WR_Byte(0x80, OLED_CMD); //--set divide ratio, Set Clock as 100 Frames/Sec
    OLED_WR_Byte(0xD9, OLED_CMD); //--set pre-charge period
    OLED_WR_Byte(0xF1, OLED_CMD); //Set Pre-Charge as 15 Clocks & Discharge as 1 Clock
    OLED_WR_Byte(0xDA, OLED_CMD); //--set com pins hardware configuration
    OLED_WR_Byte(0x12, OLED_CMD);
    OLED_WR_Byte(0xDB, OLED_CMD); //--set vcomh
    OLED_WR_Byte(0x40, OLED_CMD); //Set VCOM Deselect Level
    OLED_WR_Byte(0x20, OLED_CMD); //-Set Page Addressing Mode (0x00/0x01/0x02)
    OLED_WR_Byte(0x02, OLED_CMD); //
    OLED_WR_Byte(0x8D, OLED_CMD); //--set Charge Pump enable/disable
    OLED_WR_Byte(0x14, OLED_CMD); //--set(0x10) disable
    OLED_WR_Byte(0xA4, OLED_CMD); // Disable Entire Display On (0xa4/0xa5)
    OLED_WR_Byte(0xA6, OLED_CMD); // Disable Inverse Display On (0xa6/a7)
    OLED_Clear();
    OLED_WR_Byte(0xAF, OLED_CMD);
    //printf("OLED \r\n");
}

